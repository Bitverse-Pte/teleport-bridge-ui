import * as ethUtil from 'ethereumjs-util'
import * as env from 'detect-browser'
import { get, omit } from 'lodash'

import { CHAIN_DATA_LIST } from '../constants'
import { IInjectedProvidersMap, ChainData, ThemeColors, RequiredOption, FullProviderInfo } from './types'
import { providers, injected } from '../providers'

import { IChainData } from './types'
import SupportedChains from './chains'
import { apiGetGasPrices, apiGetAccountNonce } from './api'
import { convertAmountToRawNumber, convertStringToHex } from './bignumber'

export function capitalize(string: string): string {
  return string
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ')
}

export function ellipseText(text = '', maxLength = 9999): string {
  if (text.length <= maxLength) {
    return text
  }
  const _maxLength = maxLength - 3
  let ellipse = false
  let currentLength = 0
  const result =
    text
      .split(' ')
      .filter((word) => {
        currentLength += word.length
        if (ellipse || currentLength >= _maxLength) {
          ellipse = true
          return false
        } else {
          return true
        }
      })
      .join(' ') + '...'
  return result
}

export function ellipseAddress(address = '', width = 10): string {
  return `${address.slice(0, width)}...${address.slice(-width)}`
}

export function padLeft(n: string, width: number, z?: string): string {
  z = z || '0'
  n = n + ''
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n
}

export function sanitizeHex(hex: string): string {
  hex = hex.substring(0, 2) === '0x' ? hex.substring(2) : hex
  if (hex === '') {
    return ''
  }
  hex = hex.length % 2 !== 0 ? '0' + hex : hex
  return '0x' + hex
}

export function removeHexPrefix(hex: string): string {
  return hex.toLowerCase().replace('0x', '')
}

export function getDataString(func: string, arrVals: any[]): string {
  let val = ''
  for (let i = 0; i < arrVals.length; i++) {
    val += padLeft(arrVals[i], 64)
  }
  const data = func + val
  return data
}

export function getChainData(chainId = 1): IChainData {
  const chainData = SupportedChains.filter((chain: any) => chain.chain_id === chainId)[0]

  if (!chainData) {
    throw new Error('ChainId missing or not supported')
  }

  const API_KEY = process.env.REACT_APP_INFURA_ID

  if (chainData.rpc_url.includes('infura.io') && chainData.rpc_url.includes('%API_KEY%') && API_KEY) {
    const rpcUrl = chainData.rpc_url.replace('%API_KEY%', API_KEY)

    return {
      ...chainData,
      rpc_url: rpcUrl,
    }
  }

  return chainData
}

export function hashPersonalMessage(msg: string): string {
  const buffer = Buffer.from(msg)
  const result = ethUtil.hashPersonalMessage(buffer)
  const hash = ethUtil.bufferToHex(result)
  return hash
}

export function recoverPublicKey(sig: string, hash: string): string {
  const sigParams = ethUtil.fromRpcSig(sig)
  const hashBuffer = Buffer.from(hash.replace('0x', ''), 'hex')
  const result = ethUtil.ecrecover(hashBuffer, sigParams.v, sigParams.r, sigParams.s)
  const signer = ethUtil.bufferToHex(ethUtil.publicToAddress(result))
  return signer
}

export function recoverPersonalSignature(sig: string, msg: string): string {
  const hash = hashPersonalMessage(msg)
  const signer = recoverPublicKey(sig, hash)
  return signer
}

export async function formatTestTransaction(address: string, chainId: number) {
  // from
  const from = address

  // to
  const to = address

  // nonce
  const _nonce = await apiGetAccountNonce(address, chainId)
  const nonce = sanitizeHex(convertStringToHex(_nonce))

  // gasPrice
  const gasPrices = await apiGetGasPrices()
  const _gasPrice = gasPrices.slow.price
  const gasPrice = sanitizeHex(convertStringToHex(convertAmountToRawNumber(_gasPrice, 9)))

  // gasLimit
  const _gasLimit = 21000
  const gasLimit = sanitizeHex(convertStringToHex(_gasLimit))

  // value
  const _value = 0
  const value = sanitizeHex(convertStringToHex(_value))

  // data
  const data = '0x'

  // test transaction
  const tx = {
    from,
    to,
    nonce,
    gasPrice,
    gasLimit,
    value,
    data,
  }

  return tx
}

export function isObject(obj: any): boolean {
  return typeof obj === 'object' && !!Object.keys(obj).length
}

export function checkInjectedProviders(): IInjectedProvidersMap {
  const result: IInjectedProvidersMap = {
    injectedAvailable: !!window.ethereum || !!window.web3,
  }
  if (result.injectedAvailable) {
    let fallbackProvider = true
    Object.values(injected).forEach((provider: FullProviderInfo) => {
      const isAvailable = verifyInjectedProvider(provider.check)
      if (isAvailable) {
        result[provider.check] = true
        fallbackProvider = false
      }
    })

    const browser = env.detect()

    if (browser && browser.name === 'opera') {
      result[injected.OPERA.check] = true
      fallbackProvider = false
    }

    if (fallbackProvider) {
      result[injected.FALLBACK.check] = true
    }
    return result
  }

  return result
}

export function verifyInjectedProvider(check: string): boolean {
  return window.ethereum ? window.ethereum[check] : window.web3 && window.web3.currentProvider && window.web3.currentProvider[check]
}

export function getInjectedProvider(): FullProviderInfo | null {
  let result = null

  const injectedProviders = checkInjectedProviders()

  if (injectedProviders.injectedAvailable) {
    const checks = Object.keys(omit(injectedProviders, 'injectedAvailable'))
    result = getProviderInfoFromChecksArray(checks)
  }
  return result
}

export function getInjectedProviderName(): string | null {
  const injectedProvider = getInjectedProvider()
  return injectedProvider ? injectedProvider.name : null
}

export function getProviderInfoFromChecksArray(checks: string[]): FullProviderInfo {
  const check = filterProviderChecks(checks)
  return filterProviders('check', check)
}

export function getProviderInfoByName(name: string | null): FullProviderInfo {
  return filterProviders('name', name)
}

export function getProviderInfoById(id: string | null): FullProviderInfo {
  return filterProviders('id', id)
}

export function getProviderInfoByCheck(check: string | null): FullProviderInfo {
  return filterProviders('check', check)
}

export function getProviderDescription(providerInfo: Partial<FullProviderInfo>): string {
  if (providerInfo.description) {
    return providerInfo.description
  }
  let description = ''
  switch (providerInfo.type) {
    case 'injected':
      description = `Connect to your ${providerInfo.name} Wallet`
      break
    case 'web':
      description = `Connect with your ${providerInfo.name} account`
      break
    case 'qrcode':
      description = `Scan with ${providerInfo.name} to connect`
      break
    case 'hardware':
      description = `Connect to your ${providerInfo.name} Hardware Wallet`
      break
    default:
      break
  }
  return description
}

export function filterMatches<T>(array: T[], condition: (x: T) => boolean): T | undefined {
  const matches = array.filter(condition)

  if (!!matches && matches.length) {
    return matches[0]
  }
}

interface Te {
  [key: string]: boolean
}

const c = 'a'
const d: Te = {
  a: false,
}
console.log(d[c])

export function filterProviders(param: string, value: string | null): FullProviderInfo {
  if (!value) return injected.FALLBACK

  const match = filterMatches<Omit<FullProviderInfo, 'injectedAvailable'>>(Object.values(providers), (x) => get(x, param) === value) || injected.FALLBACK
  return match || injected.FALLBACK
}

export function filterProviderChecks(checks: string[]): string {
  if (!!checks && checks.length) {
    if (checks.length > 1) {
      if (checks[0] === injected.METAMASK.check || checks[0] === injected.CIPHER.check) {
        return checks[1]
      }
    }
    return checks[0]
  }
  return injected.FALLBACK!.check
}

export function getChainId(network: string): number {
  const chains: ChainData[] = Object.values(CHAIN_DATA_LIST)
  const match = filterMatches<ChainData>(chains, (x) => x.network === network)
  if (!match) {
    throw new Error(`No chainId found match ${network}`)
  }
  return match.chainId
}

export function findMatchingRequiredOptions(requiredOptions: RequiredOption[], providedOptions: { [key: string]: any }): RequiredOption[] {
  const matches = requiredOptions.filter((requiredOption) => {
    if (typeof requiredOption === 'string') {
      return requiredOption in providedOptions
    }
    const matches = findMatchingRequiredOptions(requiredOption, providedOptions)
    return matches && matches.length
  })
  return matches
}
